import { Any } from "../../../google/protobuf/any";
import * as Long from "long";
import { Writer, Reader } from "protobufjs/minimal";
import { Coin } from "../../../cosmos/base/v1beta1/coin";
import { Duration as Duration1 } from "../../../google/protobuf/duration";
export declare const protobufPackage = "cosmos.feegrant.v1beta1";
/**
 * BasicFeeAllowance implements FeeAllowance with a one-time grant of tokens
 * that optionally expires. The delegatee can use up to SpendLimit to cover fees.
 */
export interface BasicFeeAllowance {
    /**
     * spend_limit specifies the maximum amount of tokens that can be spent
     * by this allowance and will be updated as tokens are spent. If it is
     * empty, there is no spend limit and any amount of coins can be spent.
     */
    spendLimit: Coin[];
    /** expiration specifies an optional time when this allowance expires */
    expiration?: ExpiresAt;
}
/**
 * PeriodicFeeAllowance extends FeeAllowance to allow for both a maximum cap,
 * as well as a limit per time period.
 */
export interface PeriodicFeeAllowance {
    /** basic specifies a struct of `BasicFeeAllowance` */
    basic?: BasicFeeAllowance;
    /**
     * period specifies the time duration in which period_spend_limit coins can
     * be spent before that allowance is reset
     */
    period?: Duration;
    /**
     * period_spend_limit specifies the maximum number of coins that can be spent
     * in the period
     */
    periodSpendLimit: Coin[];
    /** period_can_spend is the number of coins left to be spent before the period_reset time */
    periodCanSpend: Coin[];
    /**
     * period_reset is the time at which this period resets and a new one begins,
     * it is calculated from the start time of the first transaction after the
     * last period ended
     */
    periodReset?: ExpiresAt;
}
/** AllowedMsgFeeAllowance creates allowance only for specified message types. */
export interface AllowedMsgFeeAllowance {
    /** allowance can be any of basic and filtered fee allowance. */
    allowance?: Any;
    /** allowed_messages are the messages for which the grantee has the access. */
    allowedMessages: string[];
}
/**
 * Duration is a span of a clock time or number of blocks.
 * This is designed to be added to an ExpiresAt struct.
 */
export interface Duration {
    duration?: Duration1 | undefined;
    blocks: Long | undefined;
}
/**
 * ExpiresAt is a point in time where something expires.
 * It may be *either* block time or block height
 */
export interface ExpiresAt {
    time?: Date | undefined;
    height: Long | undefined;
}
/** FeeAllowanceGrant is stored in the KVStore to record a grant with full context */
export interface FeeAllowanceGrant {
    granter: string;
    grantee: string;
    allowance?: Any;
}
export declare const BasicFeeAllowance: {
    encode(message: BasicFeeAllowance, writer?: Writer): Writer;
    decode(input: Reader | Uint8Array, length?: number | undefined): BasicFeeAllowance;
    fromJSON(object: any): BasicFeeAllowance;
    fromPartial(object: DeepPartial<BasicFeeAllowance>): BasicFeeAllowance;
    toJSON(message: BasicFeeAllowance): unknown;
};
export declare const PeriodicFeeAllowance: {
    encode(message: PeriodicFeeAllowance, writer?: Writer): Writer;
    decode(input: Reader | Uint8Array, length?: number | undefined): PeriodicFeeAllowance;
    fromJSON(object: any): PeriodicFeeAllowance;
    fromPartial(object: DeepPartial<PeriodicFeeAllowance>): PeriodicFeeAllowance;
    toJSON(message: PeriodicFeeAllowance): unknown;
};
export declare const AllowedMsgFeeAllowance: {
    encode(message: AllowedMsgFeeAllowance, writer?: Writer): Writer;
    decode(input: Reader | Uint8Array, length?: number | undefined): AllowedMsgFeeAllowance;
    fromJSON(object: any): AllowedMsgFeeAllowance;
    fromPartial(object: DeepPartial<AllowedMsgFeeAllowance>): AllowedMsgFeeAllowance;
    toJSON(message: AllowedMsgFeeAllowance): unknown;
};
export declare const Duration: {
    encode(message: Duration, writer?: Writer): Writer;
    decode(input: Reader | Uint8Array, length?: number | undefined): Duration;
    fromJSON(object: any): Duration;
    fromPartial(object: DeepPartial<Duration>): Duration;
    toJSON(message: Duration): unknown;
};
export declare const ExpiresAt: {
    encode(message: ExpiresAt, writer?: Writer): Writer;
    decode(input: Reader | Uint8Array, length?: number | undefined): ExpiresAt;
    fromJSON(object: any): ExpiresAt;
    fromPartial(object: DeepPartial<ExpiresAt>): ExpiresAt;
    toJSON(message: ExpiresAt): unknown;
};
export declare const FeeAllowanceGrant: {
    encode(message: FeeAllowanceGrant, writer?: Writer): Writer;
    decode(input: Reader | Uint8Array, length?: number | undefined): FeeAllowanceGrant;
    fromJSON(object: any): FeeAllowanceGrant;
    fromPartial(object: DeepPartial<FeeAllowanceGrant>): FeeAllowanceGrant;
    toJSON(message: FeeAllowanceGrant): unknown;
};
declare type Builtin = Date | Function | Uint8Array | string | number | undefined | Long;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
